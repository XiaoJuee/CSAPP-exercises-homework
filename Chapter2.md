
@[TOC](《深入理解计算机系统》第二章)
# 练习题
## 练习题2.1 完成下面的数字转换:
A. 将0x39A7F8转换为二进制
``0011 1001 1010 0111 1111 1000``
``  3   9    A    7     F    8 ``
做法就是把每个数字/字母按顺序写(转为4位二进制)即可

B. 将二进制``1100100101111011``转换为十六进制
按照上面的反向操作，四位一组转为对应十六进制即可
``0xC97B``

C.将``0xD5E4C``转换为二进制
``11010101111001001100``
分组来看就是
``1101(D) 0101(5) 1110(E) 0100(4) 1100(C)``

D.将二进制``1001101110011110110101``
这个时候分组会发现：如果从前往后分就会出现最后一组只有两个的情况（这是不对的）
应该从后往前分
``10 0110 1110 0111 1011 0101``
那么最高位的一组只有两位也可以补0去看，也可以不补
``0010 0110 1110 0111 1011 0101``
答案就是
``0x26E7B5``

## 练习题2.2 填写下表中的空白项，给出2的不同次幂的二进制和十六进制表示:
|n|$2^n(十进制)$|$2^n(十六进制)$|
|--|--|--|
|9|512|0x200|
|19|||
||16 384||
|||0x10000|
|17|||
||32||
|||0x80|

**第二行: n = 19**
十进制:$2^{19} = 524288$
十六进制可以由十进制转过去，也可以通过以下方法计算
因为$16 = 2^4$
$2^{19} = 2^{4^4} \times 2^3 = 16^4 \times 8$
所以十六进制表示:``0x80000`` = $8*16^4 + 0*16^3 + 0*16^2 + 0*16^1 + 0*16^0$

**第三行：十进制 16384**
快速做法：$2^{10} = 1024$
用16384 去除以 1024 得到 16
而16是$2^4$
所以$16384 = 1024 * 16 = 2^{10} * 2^4 = 2^{14}$
所以**n = 14**
再用上面（第二行）的方法
$2^{14} = 2^{4^3} * 2^2 = 4 * 16^3$
十六进制就是``0x4000``

**第四行: 十六进制: 0x10000**
读位数发现``0x10000`` = $16^4$
$16^4 = 2^{4^4} = 2^{16}$
所以**n = 16**
转十进制就没啥技巧了计算$16^4$或者$2^{16}$即可

**第五到七行重复二到四行的方法即可得到答案**

完整答案：
|n|$2^n(十进制)$|$2^n(十六进制)$|
|--|--|--|
|9|512|0x200|
|19|524 288|0x80000|
|14|16 384|0x4000|
|16|65 536|0x10000|
|17|131 072|0x20000|
|5|32|0x20|
|7|128|0x80|

## 练习题2.3 一个字节可以用两个十六进制数字表示。填写下表中缺失的项，给出不同字节模式的十进制、二进制和十六进制值：
|十进制|二进制|十六进制|
|--|--|--|
|0|0000 0000|0x00|
|167|||
|62|||
|188|||
||0011 0111||
||1000 1000||
||1111 0011||
|||0x52|
|||0xAC|
|||0xE7|

这题的技巧就是遇到十进制和二进制首先转为十六进制
1. 二进制转十六进制更快 ， 十六进制转十进制乘法运算更少
2. 十进制转十六进制比转二进制快(况且还是只有两个十六进制数字)

**第二行 十进制: 167**
通过计算或者直觉可得$167 = 16*10 + 7$
所以十六进制为``0xA7``
二进制为``1010 01111``

**第五行 二进制 0011 0111**
转为十六进制为``0x37``
转为十进制为$3*16^1 + 7 = 55$

**第八行 十六进制0x52**
转为十进制:$5*16+2 = 82$
转为二进制:``0101 0010``

完整答案:
|十进制|二进制|十六进制|
|--|--|--|
|0|0000 0000|0x00|
|167|1010 01111|0xA7|
|62|0011 1110|0x3E|
|188|1011 1100|0xBC|
|55|0011 0111|0x37|
|136|1000 1000|0x88|
|243|1111 0011|0xF3|
|82|0101 0010|0x52|
|172|1010 1100|0xAC|
|231|1110 0111|0xE7|

## 练习题2.4 不将数字转换为十进制或者二进制，试着解答下面的算术题，答案用十六进制表示。

**A. 0x503c + 0x8 =** 
对齐位，做第一次加法``c + 8 = 20`` , 保留 ``20 - 16 = 4``并且进一位
所以答案为``0x5044``

**B. 0x503c - 0x40 =**
最低位做减法，个位为``c-0 = c``
次低位做减法，十位为``3 - 4 = -1``向高位借一位``16+3 - 4 = 15 = F``
接着继续借位即可
所以答案为``0x4FFc``

**C.0x503c + 64 =0x507c**
将``64``转为十六进制``0x40``然后做加法即可

**D.0x50ea-0x503c=0xAE**

## 练习题2.5 思考下面对 show_bytes的三次调用:
```c
int val = 0x87654321;
byte_pointer valp = (byte_pointer) & val;
show_bytes(valp,1);/*A.*/
show_bytes(valp,2);/*B.*/
show_bytes(valp,3);/*C.*/
```
指出在小端法机器和大端法机器上，每次调用的输出值。
A.小端法: 大端法:
B.小端法: 大端法:
C.小端法: 大端法:

``show_bytes()``函数如下(在书的上面)
```c
typedef unsigned char *byte_pointer;
void show_bytes(byte_pointer start, size_t len){
    size_t i;
    for(i = 0 ;i < len ; i++)
        printf(" %.2x", start[i]);
    printf("\n");
}
```
**小端法:**
首先明白小端其实是最低有效字节在最前面的方式
低地址``0x21 0x43 0x65 0x87``高地址
**大端法:**
低地址``0x87 0x65 0x43 0x21``高地址

然后看第二个参数传的是打印的长度
所以
**A.大端法:``0x21``**
**A.小端法:``0x87``**
**B.大端法:``0x21 0x43``**
**B.小端法:``0x87 0x65``**
**C.大端法:``0x21 0x43 0x65 ``**
**C.小端法:``0x87 0x65 0x43``**

注：答案没有空格（空格是为了看的方便）

## 练习题2.6 使用show_int 和show_float,我们确定整数3510593的十六进制表示为0x00359141,二浮点数3510593.0的十六进制表示为0x4A564504。
A.写出这两个十六进制值的二进制表示。
B.移动这两个二进制串的相对位置，使得它们相匹配的位数最多。有多少位相匹配呢？
C.串中的什么部分不相匹配？

A.
``0x00359141``转为二进制:``0000 0000 0011 0101 1001 1001 0001 0100 0001``
``0x4A564504``转为二进制:``0100 1010 0101 0110 0100 0101 0000 0100``

B.
``000000000011010110011001000101000001``
`` .01001010010101100100010100000100``
23位相匹配

书上说21位匹配(暂时没研究明白)

C. ??? (个人觉得问的有点迷)

书上答案:
我们发现除了最高有效位1，整数的所有位都嵌在浮点数中。这正好也是书中示例的情况。另外，浮点数有一些非零的高位不与整数中的高位相匹配。

## 练习题2.7 下面对show_bytes的调用将输出什么结果？
```c
const char *s = "abcdef";
show_bytes((byte_pointer)s,strlen(s));
```
答案：依次打印``'a'-''f``的ASCLL码即可
``0x61 0x62 0x63 0x64 0x65 0x66``

## 练习题2.8 填写下表，给出位向量的布尔运算的求值结果。
|运算|结果|
|--|--|
|$a$|$[01101001]$|
|$b$|$[01010101]$|
|~a||
|~b||
|a&b||
|$a\|b$||
|a^b||

记住
按位且(&)是全1则1
按位或(|)是有1则1
按位异或(^)是有异(不同)则1
按位取反是1/0互换

完整答案:
|运算|结果|
|--|--|
|$a$|$[01101001]$|
|$b$|$[01010101]$|
|~a|$[10010110]$|
|~b|$[10101010]$|
|a&b|$[01000001]$|
|$a\|b$|$[01111101]$|
|a^b|$[00111100]$|

## 练习题2.9 通过混合三种不同颜色的光（红绿蓝），计算机可以在视屏屏幕或者液晶显示屏上产生彩色的画面。设想一种简单的方法，使用三种不同颜色的光，每种光都能打开或关闭，投射到玻璃屏幕上。

那么基于光源RGB的开关，我们就能创建8种不同的颜色
|R|G|B|颜色|
|-|-|-|-|
|0|0|0|黑色|
|0|0|1|蓝色|
|0|1|0|绿色|
|0|1|1|蓝绿色|
|1|0|0|红色|
|1|0|1|红紫色|
|1|1|0|黄色|
|1|1|1|白色|

这些颜色中的每一种都能用一个长度为3的位向量来表示，我们可以对它们进行布尔运算。

**A.一种颜色的补是通过关掉打开的光源，且打开关闭的光源而形成的那么上面列出的八种颜色每一种的补是什么？**

|颜色|补 颜色|
|-|-|
|黑色|白色|
|蓝色|黄色|
|绿色|红紫色|
|蓝绿色|红色|
|红色|蓝绿色|
|红紫色|绿色|
|黄色|蓝色|
|白色|黑色|

**B.描述下列颜色应用布尔运算的结果：**
蓝色 | 绿色 = 蓝绿色
黄色 & 蓝绿色 = 绿色
红色 ^ 红紫色 = 蓝色

## 练习题 2.10 对于任一位向量a，有a^a = 0.应用这一属性，考虑下面的程序：
```c
void inplace_swap(int *x,int *y){
    *y = *x^*y;/*Step 1*/
    *x = *x^*y;/*Step 2*/
    *y = *x^*y;/*Step 3*/
}
```
|步骤|*x|*y|
|-|-|-|
|初始|a|b|
|第1步|a|a^b|
|第2步|a ^ (a ^ b) = (a ^ a) ^ b = b|a^b|
|第1步|b|b ^ (a ^ b) = (b ^ b) ^ a = a|

## 练习题2.11 在练习题2.10中的inplace_swap函数的基础上，你决定写一段代码，实现将一个数组中的元素头尾两端依次对调。你写出下面这个函数：
```c
void reverse_array(int a[],int cnt){
    int first,last;
    for(first = 0,last = cnt - 1;
        first <= last;
        first++,last--)
        inplace_swap(&a[first],&a[last])
}
```

**A.对于一个长度为奇数的数组，长度cnt = 2k+1,函数 reverse_array最后一次循环中，变量first和last的值分别是什么？**
$first = last = \lfloor \dfrac{cnt}{2} \rfloor = k$

**B.为什么这时调用函数inpalce_swap会将数组元素设置为0**
设$b = a[k]$
|步骤|*x|*y|
|-|-|-|
|初始|b|b|
|第1步|0|b^b = 0|
|第2步|0|0|
|第1步|0|0|

**在第一步自己和自己异或变成0了还赋值给了自己**

**C.对reverse_arry的代码做哪些简单改动就能消除这个问题？**
将``first<=last``改为``first < last``
使得不会出现自己对自己交换从而避免了自己和自己异或并赋值给自己

## 练习题2.12 对于下面的值，写出变量x的C语言表达式。你的代码应该对任何字长$w\ge8$都能工作。我们给出了当x = 0x87654321以及$w = 32$时表达式求值的结果，仅供参考。

**A.x的最低有效字节，其他位均置为0.[0x00000021]**
``x & 0xFF``

**B.除了x的最有效字节外，其他位都取补，最低有效字节保持不变。[0x789ABC21]**
``(~(x&~0xFF))|(x&0xFF)``
书上答案:
``x^~0xFF``
更简洁~ ， **异或操作起到了取补的作用!**

**C.x的最低有效字节设置成全1，其他字节都保持不变**
``x|0xFF``

## 练习题2.13 
从20世纪70年代末到80年代末，Digital Equipment 的 VAX 计算机是一种非常流行的机型。它没有布尔运算 AND和 OR指令，只有 bis(位设置)和bic(位清除)这两种指令。两种指令的输入都是一个数据字x和一个掩码字 m。它们生成一个结果 z，z是由根据掩码m的位来修改x的位得到的。**使用 bis 指令，这种修改就是在m为1的每个位置上，将z对应的位设置为1。使用bic指令，这种修改就是在m为1的每个位置，将z对应的位设置为0。**
为了看清楚这些运算与C语言位级运算的关系，假设我们有两个函数bis和bic来实现位设置和位清除操作。只想用这两个函数，而不使用任何其他C语言运算，来实现按位|和^运算。填写下列代码中缺失的代码。提示:写出 bis 和bic运算的C语言表达式。

```c
int bis(int x,int m);
int bic(int x，int m);

int bool_or(int x,int y){
    int result=________
    return result;
}
int bool_xor(int x,int y){
    int result=________
    return result;
}
```
**按位或**
使用 bis 指令，这种修改就是在m为1的每个位置上，将z对应的位设置为1。
根据按位或的原理，是有1则1。而bis能让其中一个是1而另一个为0的地方将其赋值为1，最后结果和按位或一样。
所以以下两个答案都可以
```c
int bool_or(int x,int y){
    int result=bis(x,y); // result = bis(y,x);
    return result;
}
```
举例：
``x = [0101]``
``y = [0110]``
``bis(x,y)``的操作 ， 其实就是把x的第二三位变为1,结果就是``[0111]``，和按位或的一样。
反过来``bis(y,x)``，最终改变其实就是把y的最低位变为1，,结果依旧是``[0111]``。


**按位异或**
使用bic指令，这种修改就是在m为1的每个位置，将z对应的位设置为0。

**解决方案1（书本解决方案）：**
bic指令对应的C语言表达式应该是``x & ~m``
而bis指令根据上面的可知等效于按位或

根据``(~x & y) | (~y & x) = x ^ y``可得答案为``bis(bic(x,y),bic(y,x))``

这里分析一下如何出来这些东西。这里使用的是**逻辑门和真值表**进行解析。

~~剧透一下：异或门(XOR)可以用四个与非门(NAND)或者或门(OR)、非门(N)、与门(AND)各两个组成。或者更多方式...~~

首先是bic指令，列出所有情况
``bic(0,0)= 0``
``bic(1,0)= 1``
``bic(0,1)= 0``
``bic(1,1)= 0``

|输入1|0|1|0|1|
|--|--|--|--|--|
|输入2|0|0|1|1|
|bic(输入1，输入2)结果|0|1|0|0|

发现不属于任何常见的逻辑门。
那么先放一下，只好从或门和异或门的真值表入手。
如果只连接一个或门(原理就是可以先判断至少有一个1；真理就是当前我们只有或门(bis指令)，不连它连谁？)，C语言表达式是``输入1 | 输入2`` ， 真值表应该是
|输入1|0|1|0|1|
|--|--|--|--|--|
|输入2|0|0|1|1|
|预期结果|0|1|1|0|
|当前输出|0|1|1|1|

发现只有第四种情况是错的，
我们要排除两个都是绿的这种情况，我们在输出2上添加一条支路，在上面加入一个非门，并且对此产生的结果进行一个与门判断，就变成了“输入1和输入2至少一个为1，并且输入2不是1的时候，输出1”

用C语言表达式就变成了``(输入1 | 输入2) &  ~输入2``
|输入1|0|1|0|1|
|--|--|--|--|--|
|输入2|0|0|1|1|
|预期结果|0|1|1|0|
|当前输出|0|1|0|0|

**上表为本题所示表1(重点注意)**

这个时候真值表第三种情况又出现问题，我们还需要“输入1和输入2至少一个为1，并且输入1不是1的时候，输出1”
相当于``(输入1 | 输入2) &  ~输入1``
|输入1|0|1|0|1|
|--|--|--|--|--|
|输入2|0|0|1|1|
|预期结果|0|1|1|0|
|当前输出|0|0|1|0|

这两个大情况都可以成立，所以加上一个或在中间(把两个结果用或门连接)
用C语言表达式就变成了``((输入1 | 输入2) &  ~输入2) | ((输入1 | 输入2) &  ~输入1)``

这时候我们回头看bic指令。发现刚刚C语言表达式是``(输入1 | 输入2) &  ~输入2``的真值表恰好和bic指令的真值表一模一样！而``(输入1 | 输入2) &  ~输入1``可以看作``(输入1 | 输入2) &  ~输入2``将输入1和输入2进行调换得到。

用bic指令代替上面的表达式答案就变为了``bic(输入1,输入2)|bic(输入2，输入1)``
而或门恰好是bis指令，再将输入1和输入2替换为题目的x,y

答案就变成了``bis(bic(x,y),bic(y,x))``

至于``(~x & y) | (~y & x) = x ^ y``中的``~x & y``其实是上面讲的``(x|y)&~x``简化得来，按照真值表的说法``(x|y)&~x``其实是(x为1或者y为1)并且x不为1,所以如果x为1那肯定结果不为1，如果x为0，只看y为不为1即可，所以和``y & ~x``y为1且x为0是等价的。

**解决方案2:**
回顾异或操作
``0 ^ 0 = 0``
``1 ^ 1 = 0``
``0 ^ 1 = 1``
``1 ^ 0 = 1``
那么不妨把x设为``[0101]`` , y 设为 ``[0110]``
我们知道如果进行``bis(x,y)和bis(y,x)``得到的答案是``[0111]``
那么进行``bic(x,y)``得到的答案应该是``[0001]``
进行``bic(y,x)``得到的答案应该是``[0010]``
这个时候再把答案进行结合发现``[0001] | [0010] = [0011]``
因为这是二进制的所有情况，所以答案必定是``bis(bic(x,y),bic(y,x))``

```c
int bool_xor(int x,int y){
    int result=bis(bic(x,y),bic(y,x))
    return result;
}
```
这样我们无论从全部情况入手还是表达式关联入手，都可以得到答案。

## 练习题 2.45 填写下表中缺失的信息:
|小数值|二进制表示|十进制表示|
|--|--|--|
|$\dfrac{1}{8}$|0.001|0.125|
|$\dfrac{3}{4}$|||
|$\dfrac{25}{16}$|||
||10.1011||
||1.001||
|||5.875|
|||3.1875|

通过书上题目上方的表，我们可以得到
|表示|值|十进制|
|--|--|--|
|$0.0_2$|$\dfrac{0}{2}$|$0.0_{10}$|
|$0.01_2$|$\dfrac{1}{4}$|$0.25_{10}$|
|$0.010_2$|$\dfrac{2}{8}$|$0.25_{10}$|
|$0.0011_2$|$\dfrac{3}{16}$|$0.1875_{10}$|
|$0.00110_2$|$\dfrac{6}{32}$|$0.1875_{10}$|
|$0.001101_2$|$\dfrac{13}{64}$|$0.203125_{10}$|
|$0.0011010_2$|$\dfrac{26}{128}$|$0.203125_{10}$|
|$0.00110101_2$|$\dfrac{51}{256}$|$0.19921875_{10}$|

**第二行:**
$\dfrac{3}{4} = \dfrac{1}{2} + \dfrac{1}{4}$

将二分之一和四分之一转为二进制，相加即可

$0.1_2 + 0.01_2 = 0.11_2$

十进制表达式就不细说了，分数转小数即可

**第三行**
先提取除一个$1_2$，就变成了$\dfrac{9}{16} \gt \dfrac{1}{2}$

所以再提取一个$0.1_2$,就变成了$\dfrac{1}{16}$

最后提出一个$0.0001_2$即可

**第四行**
先二进制转小数值（分数）
$10.1011_2 = 2 + \dfrac{1}{2} + \dfrac{1}{8} + \dfrac{1}{16} = \dfrac{44}{16}$

**第六行**
$5.875_{10} = 4 + 1 + 0.5 + 0.25 + 0.125$
技巧：
每次都从能减的最高位往下走
eg. $5.875 - 4 = 1.875$
$1.875 - 1 = 0.875$
$0.875 - 0.5 = 0.375$
...
$0.125 - 0.125 = 0$
结束

**完整答案:**
|小数值|二进制表示|十进制表示|
|--|--|--|
|$\dfrac{1}{8}$|0.001|0.125|
|$\dfrac{3}{4}$|0.11|0.75|
|$\dfrac{25}{16}$|1.1001|1.5625|
|$\dfrac{44}{16}$|10.1011|2.75|
|$\dfrac{9}{8}$|1.001|1.125|
||101.111|5.875|
||11.001|3.1875|



# 课后习题
## 2.58
```c
bool is_little_endian(){
    return 
}
```
## 2.59
```c
return (x & 0xff) | ((~0xff)&y)
```

## 2.61 写一个C表达式，在下列描述的条件下产生1，而在其他情况下得到0，假设x是int类型
### A. x的任何位都等于1
解决方案1:
INT_MAX的任何位都等于1 ， 将其与x进行按位且后如果x有一位不等于1那么结果为0
```c
bool chapter2_261A(int x){
    return x & (INT_MAX);
}
```


解决方案2:
x的任何位都等于1 , 那么将x进行取反后每一位都等于0，相当于 0
```c
bool chapter2_261A(int x){
    return !~x;
}
```

C表达式：
``!~x`` or `` x & (INT_MAX)``

### B. x的任何位都等于0
解决方案:
x的任何位都等于0 , 那么x就是0
```c
bool chapter2_261B(int x){
    return !x;
}
```

C表达式：
``!x``

### C. x的最低有效字节中的位都等于1
注意这里说的是有效**字节**
一般一个字节是8位，一个字节的位都等于1 ， 在二进制中相当于``1111 1111``,在十六进制中相当于``0xFF``
解决方案:
先提取出最低有效字节，接着判断是否为全1(可以利用2.61A的方法)
```c
bool chapter2_261C(int x){
    return chapter2_261A((x & 0xFF) | ~0xFF);
}
```

可以化简为直接将除了最低为有效字节以外的字节都替换为全1，然后利用2.61A的方法
```c
bool chapter2_261C(int x){
    return chapter2_261A(x | ~0xFF);
}
```

C表达式：
``!~(x | ~0xFF)``

### D. x的最高有效字节中的位都等于0
解决方案:
先提取出最高有效字节，接着判断是否为全0(可以利用2.61B的方法和书上的get_msb方法)
```c
int get_msb(int x){
    int shift_val = (sizeof(int)-1) << 3;
    int xright = x >> shift_val;
    return xright & 0xFF;
}
bool chapter2_261D(int x){
    return chapter2_261B(get_msb(x));
}
```
这里顺便讲解一下如何提取最高有效字节:
``sizeof(int)``获取int的字节数，然后将字节数 - 1，再乘上 8 (1 << 3)也就2的3次方，原因是一个字节是8位。
接着 ``x >> shift_val``把x右移``shift_val``位，实则是将**最高位移到最低位的位置**
最后将其与``0xFF``进行按位且，相当于截取最低位，其余位归0。
最后就能得到最高位有效字节


C表达式：
``!((x >> ((sizeof(int)-1) << 3)) & 0xFF )``

## 2.62 编写一个函数 int shifts_are_arithmetic()，在对 int类型的数使用算术右移的机器上运行时这个函数生成1，而其他情况下生成0。你的代码应该可以运行在任何字长的机器上。在几种机器上测试你的代码。

**算数右移（Arithmetic Right Shift）**：
保留符号位（最高位），即对于负数，右移时会填充 1；对于正数，右移时填充 0。
适用于有符号整数，保持数值的符号。

**逻辑右移（Logical Right Shift）**：
不考虑符号位，始终在高位填充 0。
适用于无符号整数，结果不依赖于原数的符号。

答案有很多种
**主要思想是负数右移后判断新填充的是否是1即可**
```c
int shifts_are_arithmetic(){
    int x = ~0;
    return (x>>(sizeof(int)<<3)) & x
}
```
```c
int int_shifts_are_arithemetic() {
  int num = -1;
  return !(num ^ (num >> 1));
}
```

## 2.63 将下面的C函数代码补充完整。函数srl用算术右移(由值xsra给出)来完成逻辑右移，后面的其他操作不包括右移或者除法。函数sra用逻辑右移(由值xsr1给出)来完成算术右移，后面的其他操作不包括右移或者除法。可以通过计算8*sizeof(int)来确定数据类型int中的位数w。位移量k的取值范围为0~w-1。
```c
unsigned srl(unsigned x，intk)
{
    /*Perform shift arithmetically */
    unsigned xsra=(int)x>>k;
    ...
}
int sra(int x,int k)
{
    /*Perform shift logically */
    int xsrl=(unsigned)x>>k;
    ...
}
```

对于函数srl仅仅需要把右移填充的部分直接归零即可。
首先得要产生除了最高的前k位都为0，其余为都为1的二进制串。
很容易想到``(int)-1 >> k``，但不允许右移
如果反过来将答案取反，就变成了最高的前k位都为1，其余为都为0的二进制串。
``(int)-1 << ((sizeof(int)<<3) - k)``就可以得到答案。
再将其取反的结果与xsra求按位且即可。
```c
unsigned srl(unsigned x，intk)
{
    /*Perform shift arithmetically */
    unsigned xsra=(int)x>>k;
    return xsra & ~((int)-1 << ((sizeof(int)<<3) - k))
}
```
## 2.64
```c
int any_odd_one(unsigned x) {
  return !!(0xAAAAAAAA & x);
}
```

也可以参考实验
```c
/* 
 * allOddBits - return 1 if all odd-numbered bits in word set to 1
 *   where bits are numbered from 0 (least significant) to 31 (most significant)
 *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1
 *   Legal ops: ! ~ & ^ | + << >>
 *   Max ops: 12
 *   Rating: 2
 */
int allOddBits(int x) {
  int oddBits = 0xAA | 0xAA<<8 | 0xAA<<16 | 0xAA<<24;
  return !((oddBits & x )^oddBits);
}
```

## 2.74
具体做法参考实验 1 的 subtractionOK 函数即可
```c
int tsub_ok(int x, int y) {
  int xsin = x>>31 & 0x1;
  int ysin = y>>31 & 0x1;
  int xy = x+(~y+1);
  int xysin = xy>>31 & 0x1;
  return !(xsin^ysin) | !((xsin ^ ysin) & ((xysin^xsin) | !xy)) | (!x & !y);
}
```

## 2.77
 A. K =17
 B. K =-7
 C. K =60
 D. K =-122

A.K = 17
$17 = 2^4 + 2^0$
``x = x<<4 + x``

B.K= -7
$7 = 2^3 - 2^0$
``X = X - X<<3``

C. K=60
$60 = 2^6 - 2^2$
``x = x<<6 - x<<2``

D. K-112
$112 = 2^7 - 2^4$
``x = x<<4 - x<<7``


更多更新请看[GITHUB仓库](https://github.com/XiaoJuee/CSAPP-exercises-homework/tree/main)